ASP.NET core and .NET core
    差別
        ASP 
            底層".NET Full Framework"(最低要求4.6.2)，包含 .NET core 設置理念，ex:default Kestrel 監聽 HTTP request
            允許 Middleware 對所有的 HttpRequest 請求，收到請求後會調用註冊的 Middleware 對 HttpRequest 進行處理
        .NET core
            保留了 ASP 的優點並跨平台運行
    結構
        通用
            wwwroot/ => 靜態資源的資料夾
            Properties/launchSettings.json => 透過 dotnet run 啟動時的檔案
            *.csproj => 專案檔
            Program.cs => 程式進入點
            Startup.cs => 啟動設定
            appsettings.json => 組態設定檔
        mvc、Web API
            Controller => 控制器
            Models => 模型
            Views => 檢視
        Blazor、Web App
            Pages => 所有 Razor 頁面
            Pages/_Host.cshtml => 預設首頁 (_Host.cshtml)
            Pages/*.razor => 所有 Blazor 元件(頁面)
            Shared => 共用 Blazor 元件的資料夾
            Data => 預設的資料存取類別所在的資料夾
        gRPC
            Protos => Protocol Buffer File
            Services => gRPC 服務的實作類別
NuGet
    安裝第三方套件的套件
最小 API


流程
    專案設定
        1. [使用控制器 (取消核取以使用最小 API)] 核取方塊
        2. [啟用 OpenAPI 支援] 核取方塊
PutTodoItem
    PutTodoItem 類似於 PostTodoItem，但差異在於 PutTodoItem 會使用 HTTP PUT
    以 HTTP 要求，Client 需要 send 整個更新的實體，如部分更新，要使用HTTP PATCH
Blazor
    有助於生成 Web 應用，從 Client and server 的可重組件生成 Web 應用
Web API
    HTTP 方法
        有兩種元素
            路由模板
                一個 URL 模式，用來匹配傳入的 URL 模板，包含靜態(/api/)和動態部分({id})
                ex
                    /api/articles/{id} 是一個路由模板，它匹配 /api/articles/1、/api/articles/2 等 URL
            處理程序
                有可能是方法或函式所匹配的 URL，通常位於控制器類別中，根據 HTTP 請求類型(GET、POST、PUT、DELETE等)

        Get() 如果以設定一種方式了，就不能再使用相同的方式
            1.不引入字串 => /api/hello
                [HttpGet]
                public IEnumerable<string> Get()
                {
                    return new string[] { "123", "456" }; <= string 就是泛型進來的
                }
            2.引入字串 => /api/hello/world
                [HttpGet("world")]
                public IEnumerable<string> Get()   <= 只要泛型引入甚麼型態的參數
                {
                    return new string[] { "123", "456" }; <= 這裡就要用甚麼型態的
                }
            3.引入 id  => /api/hello/id (id 打甚麼都可以)
                [HttpGet("{id}")]
                public string Get(int id) <= 傳進來的 id 為整數型態
                {
                    return id + "";  <= 後面一定要加 ""
                }
    Database First (資料庫建好資料後，從 VSstudio 讀取)
        安裝
            Microsoft.EntityFrameworkCore.SqlServer
            Microsoft.EntityFrameworkCore.Tools
        主控台輸入 (檢視 -> 其他視窗 -> 套件管理主控台)
            對專案右鍵 -> 編輯專案檔 -> 刪掉 <Nullable>enable</Nullable>、<InvariantGlobalization>true</InvariantGlobalization>
            (Tools 的指令，需下載 Tools)
            1.連接資料庫
                1.指令
                    Scaffold-DbContext "Server=Computer UseName/SQLEXPRESS; Database=資料庫名稱; User ID=帳號; Password=密碼; TrustServerCertificate=true" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -NoOnConfiguring -UseDatabaseNames -NoPluralize -Force
                    Scaffold-DbContext "Server= Computer UseName/SQLEXPRESS; Database=資料庫名稱; User ID=帳號; Password=密碼; TrustServerCertificate=true" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -NoOnConfiguring -UseDatabaseNames -NoPluralize -Force
                        -OutputDir => 輸出的東西要放到哪裡 (這裡是 Models 資料夾中(如果沒創立，它會自動創立))
                        -Force => 如果已經有了檔案，用這個指令可以覆蓋過去
                        -UseDatabaseNames => 不讓產生的檔案，自動改名，要與資料庫中的相同
                        -NoPluralize => 防止改變駝峰式命名
                        -NoOnConfiguring => 不要產生 DbContext.OnConfiguring
                2.伺服器總管 and SQL Server 總管
                    伺服器總管 -> 連線到伺服器 -> Microsoft SQL Server 資料庫檔案 -> 瀏覽找資料庫檔案(.mdf)
                更新資料庫
                    更新完資料庫後需要再透過 "Scaffold-DbContext "Server= Computer UseName/SQLEXPRESS; Database=資料庫名稱; User ID=帳號; Password=密碼; TrustServerCertificate=true" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -NoOnConfiguring -UseDatabaseNames -NoPluralize -Force"
                    再連接一次資料庫 VS studio 才會變更
                    當程式出現錯誤時，使用連接的指令也會出現錯誤，所以要先找出程式的錯誤
            2.DI 注入 (加入到 Program.cs 中)
                builder.Services.AddDbContext<TodoContext>(options =>  // 這段是做 DI 注入，將資料庫透過泛型的方式加入
                    options.UseSqlServer(builder.Configuration.GetConnectionString("連接字串的屬性"))); // 取得連接字串內容(appsettings.json 裡的 ConnectionStrings 的內容)
            3.掛上本地的
                Scaffold-DbContext "Data Source=(LocalDB)\MSSQLLocalDB;AttachDbFilename=D:\SQL\Todo\Todo.mdf(mdf檔案路徑);Integrated Security=True;Connect Timeout=30" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Force -CoNtext TodoContext
        GET
            取得資料 (GET)
                1.編程寫法
                    // from => 自定一個變數 in => 在某個目的地找
                    var result = from a in _todoContext.TodoLists
                        // where => 判斷式
                        // 透過物件方式呼叫屬性值
                        where a.Name == "去開會"
                        // select 收集
                        select a;
                    return result;
                2.lambda 寫法
                    var result2 = _todoContext.TodoLists.Where(a => a.Name == "去上課");
                    return result2;
            取得資料(透過字串)
                1.
                    [HttpGet("{id}")]
                    public IEnumerable<TodoList> Get(int id)
                    {
                        var result4 = from a in _todoContext.TodoLists
                                    where (a.Orders == id) <= 引用了 TodoList.cs 裡面的 public int Orders
                                    select a;
                        return result4;
                    }
                2.更嚴謹
                    [HttpGet("{id}")]
                    public TodoListSelectDto Get(Guid id)
                    {
                        var result4 = (from a in _todoContext.TodoLists
                                    where (a.TodoId == id)
                                    select new TodoListSelectDto
                                    {
                                        Enable = a.Enable,
                                        InsertEmployeeName = a.InsertEmployee.Name,
                                        InsertTime = a.InsertTime,
                                        Name = a.Name,
                                        Orders = a.Orders,
                                        TodoId = a.TodoId,
                                        UpdateEmployeeName = a.UpdateEmployee.Name,
                                        UpdateTime = a.UpdateTime,
                                    }).SingleOrDefault(); <= SingleOrDefault 是如果沒有取到資料 result 會變成 null
                                    // 另一個 Single() 只要取到兩筆或以上的資料會當機，而如果沒取到也會當機
                        return result4;
                    }
            取得資料(資料表有無外鍵設定)
                有外鍵
                    [HttpGet("{id}")]
                    public TodoListSelectDto Get(Guid id)
                    {
                        var result = (from a in _todoContext.TodoLists
                                    where a.TodoId == id
                                    select new TodoListSelectDto
                                    {
                                        Enable = a.Enable,
                                        InsertEmployeeName = a.InsertEmployee.Name, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        InsertTime = a.InsertTime, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        Name = a.Name,
                                        Orders = a.Orders,
                                        TodoId = a.TodoId,
                                        UpdateEmployeeName = a.UpdateEmployee.Name, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        UpdateTime = a.UpdateTime // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                    }).SingleOrDefault();
                        return result;
                    }
                無外鍵
                    [HttpGet("{id}")]
                    public TodoListSelectDto Get(Guid id)
                    {
                        var result = (from a in _todoContext.TodoLists
                                    // 將別的資料表的資料加進來，equals 確定兩個資料表是否相等
                                    join b in _todoContext.Employees on a.InsertEmployeeId equals b.EmployeeId
                                    join c in _todoContext.Employees on a.UpdateEmployeeId equals c.EmployeeId
                                    where a.TodoId == id
                                    select new TodoListSelectDto
                                    {
                                        Enable = a.Enable,
                                        InsertEmployeeName = b.Name, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        InsertTime = a.InsertTime, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        Name = a.Name,
                                        Orders = a.Orders,
                                        TodoId = a.TodoId,
                                        UpdateEmployeeName = c.Name, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        UpdateTime = a.UpdateTime // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                    }).SingleOrDefault();
                        return result;
                    }
            關鍵字搜尋
                /api/todo?{name}
                Contains() and IsNullOrWhiteSpace()
                    [HttpGet]
                    public IEnumerable<TodoListSelectDto> Get(string name,bool? enable,DateTime? UpdateTime)
                    {
                        // Include => 將資料表從別的地方撈過來
                        var result = _todoContext.TodoLists.Include( a => a.UpdateEmployee).Include( a => a.InsertEmployee)
                            .Select ( a => new TodoListSelectDto
                            {
                                Enable = a.Enable,
                                InsertEmployeeName = a.InsertEmployee.Name,
                                InsertTime = a.InsertTime,
                                Name = a.Name,
                                Orders = a.Orders,
                                TodoId = a.TodoId,
                                UpdateEmployeeName = a.UpdateEmployee.Name,
                                UpdateTime = a.UpdateTime
                            });
                        if(!string.IsNullOrWhiteSpace(name)) <= IsNullOrWhiteSpace() 確認是不是空值
                        {
                            // 只有字串能使用 Contains
                            result = result.Where(a => a.Name.Contains(name)); <= Contains 只要有部分相同就可以
                            result = result.Where(a => a.Name == name);
                        }
                        if(enable != null) // 要將上面的 enable 參數設定成 bool? enable 表示不一定會傳進來
                        {
                            result = result.Where(a => a.Enable == enable);
                        }
                        if(InsertTime != null)
                        {
                            result = result.Where(a => a.InsertTime.Date == InsertTime);
                        }
                        return result;
                    }
            參數化並過濾接受值
                尋找參數機制
                    資料繫結
                        語法
                            [ApiController] => 1.路由需求 2.HTTP 400 自動回應(判斷式) 3.繫結來源參數推斷 4.錯誤狀態碼的問題詳細資料
                                https://learn.microsoft.com/zh-tw/aspnet/core/web-api/?view=aspnetcore-8.0
                            路由
                                [FromQuery] => 要求查詢字串參數(?Enable=true 就是查詢字串)
                                [FromBody] => 要求本文(JSON or XML 取得參數值)
                                [FromRoute] => 來自目前要求的路由資料 ex:HttpGet("{id}") // id 就會被取的參數值
                                [FromForm] => 來自目前要求的路由資料
                                [FromHeader] => 要求標頭
                                [FromServices] => 作為動作參數插入的要求服務
                            驗證 (最好寫在 DTO 裡面)
                                其他相關語法
                                    https://learn.microsoft.com/zh-tw/aspnet/core/mvc/models/validation?view=aspnetcore-8.0
                                [Required] => 幫助驗證 POST 資料是否有東西
                                [Range(2,3)] => 可以用在需要輸入數字的地方，可以顯示範圍內的數字
                                [EmailAddress] => 驗證是否為 Email 格式
                                [EmailAddress(ErrorMessage ="輸入電子郵件")] => 也可以更改錯誤時的訊息
                            類型
                                IActionResult
                                    會回傳各種 ActionResult 型別的 HTTP 狀態碼，常見
                                        BadRequestResult(400)
                                        NotFoundResult(404)
                                        OkObjectResult(200)
                            型別
                                ActionResult
                                    針對 Controller 的 action 包含 ActionResult<T> 傳回型別，可傳回衍生自 ActionResult 型別或傳回特定型別，透過 IActionResult 提供
                                    優點
                                        1.可排除 [ProducesResponeseType] 屬性的 Type 屬性
                                            [ProducesResponeseType(200,Type=typeof(Product))] 簡化為 [ProducesResponeseType(200)] 會被 ActionResult 中斷
                                        2.隱含轉型運算子
                                            支援 T 和 ActionResult 轉換成 ActionResult<T>，T 轉換為 ObjectResult => return new ObjectResult(T)，以簡化為 return T
                            Startup
                                AddControllers
                                AddApplicationServices
                                IsDevelopment
                        使用情境
                            1.大多數情況，都會有預設值
                                public IActionResult Get(string id)
                                {
                                }
                                public IActionResult Get([FromQuery]string id)
                                {
                                }
                                id 來源會是 [FromQuery]
                            2.FromRoute
                                [HttpGet("{id}")] <= 這裡加 "{id}" 下面的 Get() 中就不用再特別寫 [FromRoute]
                                public IActionResult Get(string id)
                                {
                                }
                                [HttpGet("{id}")]
                                public IActionResult Get([FromRoute]string id) <= 而如果這裡寫 [FromQuery] 就不會取得路由的 id
                                {
                                }
                                因為會從 HttpGet("{id}") 取得 {id} 參數使用
                            3.[FromBody]
                                將所有參數都變成一個類別，預設就會變成 [FromBody]，還有在取得 JSON 或 XML 等 API 資料時，預設也是 [FromBody]
                                ex
                                    [HttpGet("{id}")]
                                    public IActionResult Get(TodoSelectParameter value)
                                    {
                                    }
                                    [HttpGet("{id}")]
                                    public IActionResult Get([FromBody] TodoSelectParameter value)
                                    {
                                    }
                            4.[FromForm]
                                通常會使用在上傳檔案時
                保留字
                    @ 
                        1.保留字
                            當要使用 C# 中的保留字當變量時，就需要"@"當前綴
                            (https://xianlee.gitbooks.io/csharp-basic/content/syntax/identifier.html)
                        2.避免跳脫字元(字面量識別符)
                            告訴編譯器將字符串視為原始字面量，也就是將字串視為字串，而不是語法使用
                                @"\n" => 加了"@"，編譯器會解釋為"\n"字串，而不是換行語法
                正則表達式
                    Regex => 使用正則表達式時需要使用，並建立一個 Regex 的實例
                    ^ => 開始位置
                    \d => 表示零個或多個數字
                    * => 比較出現次數(零次或多次) ex:Gooo*gle => 可以匹配 Gooogle or Google 等
                    + => 比較出現次數(至少一次或多次) ex:Gooo*gle => 可以匹配 Gooogle or Goooogle 等，但不能匹配到 Google
                    - => 連字符
                    $ => 結束位置
                ex
                    // 參數方
                    public class TodoSelectParameter
                    {
                        public string name { get; set; }
                        public bool? enable { get; set; }
                        public DateTime? InsertTime { get; set; }
                        public int? minOrder { get; set; }
                        public int? maxOrder { get; set; }
                        public string _order;
                        public string Order
                        {
                            get { return _order; }  // 必須使用 {}
                            set
                            {
                                // 經過這裡就可以寫成 Order=3-5
                                // 如果是符合 2-3 這種類型的參數
                                Regex regex = new Regex(@"^\d*-\d$");
                                if (regex.Match(value).Success)
                                {
                                    // 以"-"為分界點
                                    // Int32.Parse => 將字串轉為整數型別
                                    // [0] => 以"-"分割後第一個數字，2
                                    minOrder = Int32.Parse(value.Split('-')[0]);
                                    // [1] => 以"-"分割後第二個數字，3
                                    maxOrder = Int32.Parse(value.Split('-')[1]);
                                }
                                _order = value;
                            }
                        }
                    }
                    // 控制器方
                    // [FromQuery] 指定要從哪裡找資料
                    public IEnumerable<TodoListSelectDto> Get([FromQuery]TodoSelectParameter value)
                    {
                        // Include => 將資料表從別的地方撈過來
                        var result = _todoContext.TodoLists.Include( a => a.UpdateEmployee).Include( a => a.InsertEmployee)
                            .Select ( a => new TodoListSelectDto
                            {
                                Enable = a.Enable,
                                InsertEmployeeName = a.InsertEmployee.Name,
                                InsertTime = a.InsertTime,
                                Name = a.Name,
                                Orders = a.Orders,
                                TodoId = a.TodoId,
                                UpdateEmployeeName = a.UpdateEmployee.Name,
                                UpdateTime = a.UpdateTime
                            });
                        if(!string.IsNullOrWhiteSpace(value.name))
                        {
                            // result = result.Where(a => a.Name.Contains(name));
                            result = result.Where(a => a.Name == value.name);
                            result = result.Where(a => a.Name.IndexOf(value.name)>-1);
                        }
                        if(value.enable != null) // 要將上面的 enable 參數設定成 bool? enable 表示不一定會傳進來
                        {
                            result = result.Where(a => a.Enable == value.enable);
                        }
                        if(value.InsertTime != null)
                        {
                            result = result.Where(a => a.InsertTime.Date == value.InsertTime);
                        }
                        if (value.minOrder != null && value.maxOrder != null) // 要將上面的 enable 參數設定成 bool? enable 表示不一定會傳進來
                        {
                            result = result.Where(a => a.Orders >= value.minOrder && a.Orders <= value.maxOrder);
                        }
                        
                        return result;
                    }
                    一般的宣告也可以使用
                    public TodoListSelectDto Get([FromQuery] Guid id){...}
            DTO 函式化
            將兩處相同(一致)的地方，用函式帶入，減少程式碼量與提高重用性
            單筆資料(將多筆資料轉為一筆資料輸出)
                有使用 join
                    public TodoListSelectDto Get(Guid id)
                    {
                        var result =(from a in _todoContext.TodoLists
                                    // 將別的資料表的資料加進來，equals 確定兩個資料表是否相等
                                    join b in _todoContext.Employees on a.InsertEmployeeId equals b.EmployeeId
                                    join c in _todoContext.Employees on a.UpdateEmployeeId equals c.EmployeeId
                                    where a.TodoId == id
                                    // 函式化 Dto
                                    select new TodoList
                                    {
                                        Enable = a.Enable,
                                        InsertEmployee = b, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        InsertTime = a.InsertTime, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        Name = a.Name,
                                        Orders = a.Orders,
                                        TodoId = a.TodoId,
                                        UpdateEmployee = c, // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                        UpdateTime = a.UpdateTime // 資料表中有設定成外鍵，所以才能從別的地方撈到
                                    }).SingleOrDefault();
                        // 將回傳的類型轉換成 ItemToDto 類型
                        return ItemToDto(result);
                    }
                無使用 join
                    [HttpGet("{id}")]
                    public TodoListSelectDto Get(Guid id)
                    {
                        var result = (from a in _todoContext.TodoLists
                                    where a.TodoId == id
                                    // 函式化 Dto
                                    select a)
                                    .Include(a => a.UpdateEmployee)
                                    .Include(a => a.InsertEmployee).SingleOrDefault();
                        // 將回傳的類型轉換成 ItemToDto 類型
                        return ItemToDto(result);
                    }
            多筆資料
                public IEnumerable<TodoListSelectDto> Get([FromQuery]TodoSelectParameter value)
                {
                    // Include => 將資料表從別的地方撈過來
                    var result = _todoContext.TodoLists.Include( a => a.UpdateEmployee).Include( a => a.InsertEmployee)
                        // 透過函式帶入
                        .Select ( a => ItemToDto(a));
                }
                private static TodoListSelectDto ItemToDto(TodoList a)
                {
                    return new TodoListSelectDto
                    {
                        Enable = a.Enable,
                        InsertEmployeeName = a.InsertEmployee.Name,
                        InsertTime = a.InsertTime,
                        Name = a.Name,
                        Orders = a.Orders,
                        TodoId = a.TodoId,
                        UpdateEmployeeName = a.UpdateEmployee.Name,
                        UpdateTime = a.UpdateTime
                    };
                }
            IActionResult and ActionResult (符合正規內容)
                多筆資料
                    private static TodoListSelectDto ItemToDto(TodoList a)
                    {
                        return new TodoListSelectDto
                        {
                            Enable = a.Enable,
                            InsertEmployeeName = a.InsertEmployee.Name,
                            InsertTime = a.InsertTime,
                            Name = a.Name,
                            Orders = a.Orders,
                            TodoId = a.TodoId,
                            UpdateEmployeeName = a.UpdateEmployee.Name,
                            UpdateTime = a.UpdateTime
                        };
                    }

                    // 多筆資料
                    [HttpGet]
                    public IActionResult Get([FromQuery] TodoSelectParamerter value)
                    {
                        var result = _NewTodoContext.TodoList
                            .Include(a => a.InsertEmployee)
                            .Include(a => a.UpdateEmployee)
                            .Select(a => a);
                        if (!string.IsNullOrWhiteSpace(value.name))
                        {
                            // Contains 包含就為 True
                            result = result.Where(a => a.Name.Contains(value.name));
                        }
                        if (value.enable != null)
                        {
                            result = result.Where(a => a.Enable == value.enable);
                        }
                        if (value.InsertTime != null)
                        {
                            result = result.Where(a => a.UpdateTime.Date == value.InsertTime);
                        }
                        if (value.minOrder != null && value.maxOrder != null)
                        {
                            result = result.Where(a => a.Orders >= value.minOrder && a.Orders <= value.maxOrder);
                        }
                        if (result == null || result.Count() <= 0)
                        {
                            return NotFound("找不到資料");
                            // 用在新增或更新上
                            // return NoContent();
                        }
                        return Ok(result.ToList().Select(a => ItemToDto(a)));
                    }
                單筆資料
                    private static TodoListSelectDto ItemToDto(TodoList a)
                    {
                        return new TodoListSelectDto
                        {
                            Enable = a.Enable,
                            InsertEmployeeName = a.InsertEmployee.Name,
                            InsertTime = a.InsertTime,
                            Name = a.Name,
                            Orders = a.Orders,
                            TodoId = a.TodoId,
                            UpdateEmployeeName = a.UpdateEmployee.Name,
                            UpdateTime = a.UpdateTime
                        };
                    }

                    [HttpGet("{id}")]
                    public ActionResult Get(Guid id)
                    {
                        var result = (from a in _NewTodoContext.TodoList
                        where a.TodoId == id
                        select a)
                        .Include(a => a.InsertEmployee)
                        .Include(a => a.UpdateEmployee).SingleOrDefault(); <= 這裡如果找不到會回傳 null
                        if (result == null)
                        {
                            return NotFound("找不到資料");
                        }
                        return Ok(ItemToDto(a));
                    }
                如有明確回傳資料
                    private static TodoListSelectDto ItemToDto(TodoList a)
                    {
                        return new TodoListSelectDto
                        {
                            Enable = a.Enable,
                            InsertEmployeeName = a.InsertEmployee.Name,
                            InsertTime = a.InsertTime,
                            Name = a.Name,
                            Orders = a.Orders,
                            TodoId = a.TodoId,
                            UpdateEmployeeName = a.UpdateEmployee.Name,
                            UpdateTime = a.UpdateTime
                        };
                    }
                    [HttpGet("{id}")]
                    // 確定資料為 <TodoListSelectDto> 的型別
                    // 就不需要使用 OK 將回傳東西包住
                    public ActionResult<TodoListSelectDto> Get(Guid id)
                    {
                        var result = (from a in _NewTodoContext.TodoList
                                    where a.TodoId == id
                                    select a)
                            .Include(a => a.InsertEmployee)
                            .Include(a => a.UpdateEmployee).SingleOrDefault();

                        if (result == null)
                        {
                            return NotFound("找不到Id:" + id + "的資料");
                        }
                        return ItemToDto(result);
                    }
        Post (更新全部的資料)
            可以透過 Postman 測驗
            POST 資料
                1.先用 GET 取得資料
                2.將 URL 放到 Postman 上，然後改成 POST -> body -> Raw -> JSON
                3.程式碼範例
                    [HttpPost]
                    // 第一個 int 是傳出去的值 第二個 int 輸入的類別
                    public void Post([FromBody] TodoList value)
                    {
                        _todoContext.Add(value);
                        // 兩種寫法都可以
                        _todoContext.TodoLists.Add(value);
                        _todoContext.SaveChanges();
                        return;
                    }
                4.上面框可以輸入要新增資料(設定成 JSON 要用 JSON 格式輸入)
                5.再用 GET 確認資料是否成功
            新增子資料與父資料
        Patch (更新部分資料) (有問題)
            先安裝套件
                Microsoft.AspNetCore.JsonPatch
                Microsoft.AspNetCore.Mvc.NewtonsoftJson
            固定的使用 JsonPatchDocument 接收格式
                [HttpPatch]
                public string Patch(Guid id, [FromBody] JsonPatchDocument value)
                { ... }
        Delete
            基本寫法
                [HttpDelete("{id}")]
                public string Delete(Guid id)
                {
                    var delete = (from a in _NewTodoContext.TodoList
                                where a.TodoId == id
                                select a).SingleOrDefault();
                    if(delete != null)
                    {
                        _NewTodoContext.TodoList.Remove(delete);
                        _NewTodoContext.SaveChanges();
                    }
                    return "已完成";
                }
            刪除父與子資料(有外鍵)
                [HttpDelete("nofk/{id}")]
                public string NofkDelete(Guid id)
                {
                    var child = from a in _NewTodoContext.UploadFile
                                where a.TodoId == id
                                select a;
                    // RemoveRange 可以將資料全部刪除
                    _NewTodoContext.UploadFile.RemoveRange(child);
                    _NewTodoContext.SaveChanges();

                    var delete = (from a in _NewTodoContext.TodoList
                                where a.TodoId == id
                                select a).SingleOrDefault();
                    if (delete != null)
                    {
                        // Remove 只能一筆一筆刪除資料
                        _NewTodoContext.TodoList.Remove(delete);
                        _NewTodoContext.SaveChanges();
                    }
                    return "已完成";
                }
            刪除多筆資料
                [HttpDelete("list/{ids}")]
                public string Delete(string ids)
                {
                    List<Guid> deleteList = JsonSerializer.Deserialize<List<Guid>>(ids);

                    var delete = (from a in _NewTodoContext.TodoList
                                where deleteList.Contains(a.TodoId)
                                select a).Include(c => c.UploadFiles);
                    _NewTodoContext.TodoList.RemoveRange(delete);
                    _NewTodoContext.SaveChanges();

                    return "已完成";
                }
            刪除後返回符合規範內容
                [HttpDelete("{id}")]
                public IActionResult Delete(Guid id)
                {
                    var delete = (from a in _NewTodoContext.TodoList
                                where a.TodoId == id
                                select a).Include(c => c.UploadFiles).SingleOrDefault();
                    if(delete == null)
                    {
                        // return 404 and 找不到資料
                        NotFound("找不到資料");
                    }
                    _NewTodoContext.TodoList.Remove(delete);
                    _NewTodoContext.SaveChanges();

                    return NoContent();
                }
    常用
        屬性
            DateTime => 讀取電腦的時間 
                屬性介紹(https://learn.microsoft.com/zh-tw/dotnet/api/system.datetime?view=net-8.0)
            Guid => 常用在 id 上
            List<T> => 將 array 轉換成 List集合
                1.動態大小的數據結構
                2.有序集合
                3.支持泛型
                4.提供許多有用的方法 => 提供 Add(添加元素)、Remove(刪除元素)、Contains(檢查是否包含某元素)等
                5.支持 LinQ 語法 => 查詢與過濾
                6.可以配合方法
                    https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic.list-1?view=net-8.0
            Task<T> => 設立一個任務，搭配 async/ await 完成

        語法(LinQ and C# 可以搭配使用)
            LinQ
                from in => 到哪個資料庫的資料表中
                where => 條件式
                select => 收集資料
            C#
                Include => 包含某些屬性
                    (from a in _NewTodoContext.TodoList
                          where a.TodoId == id
                          select a)
                    .Include(a => a.UpdateEmployee)
                SingleOrDefault => 取得單筆資料(防呆機制)
                    (from a in _NewTodoContext.TodoList
                          where a.TodoId == id
                          select a)
                    .Include(a => a.UpdateEmployee).SingleOrDefault();
                Single => 取得單筆資料(如果回傳為 null or not data 會出現錯誤)
                    (from a in _NewTodoContext.TodoList
                          where a.TodoId == id
                          select a)
                    .Include(a => a.UpdateEmployee).Single();
                NotFound => 回傳狀態碼 404
                    return NotFound("找不到Id:" + id + "的資料");
                ToList => 將資料轉化為 SQL
                    string[] strArr = new string[3] { "1", "2", "3" };
                    List<string> strList = strArr.ToList();
                    foreach ( string item in strList) <= 可以搭配 foreach 把資料印出來
                    {
                        Console.WriteLine(item);
                    }
                Select => 將序列的每個元素規劃成一個新的表單
                    string[] fruits = { "apple", "banana", "mango", "orange",
                      "passionfruit", "grape" };
                    var query =
                        fruits.Select((fruit, index) =>
                                        new { index, str = fruit.Substring(0, index) });

                    foreach (var obj in query)
                    {
                        Console.WriteLine("{0}", obj);
                    }

                    /*
                        This code produces the following output:

                        { index = 0, str =  }
                        { index = 1, str = b }
                        { index = 2, str = ma }
                        { index = 3, str = ora }
                        { index = 4, str = pass }
                        { index = 5, str = grape }
                    */
                Count => 計算 array 中元素的數量
                    result.Count() <= 0
                Where => 條件式
                    result.Where(a => a.Enable == value.enable)
                Contains => 檢查 array 中包含的元素
                    Contains(value.name)
                IsNullOrWhiteSpace => 檢查字串是否為 null、空白 or 由空白字元組成
                    string.IsNullOrWhiteSpace(value.name) <= value 只能為字串
                Parse => 前面可以搭配 int、bool、Guid 等各種類型
                Find => 只能放入資料的主 key(id)
其他套件            
    AutoMapper
        1.安裝 AutoMapper.Extensions.Microsoft.DependencyInjection
        2.到 Startup(or Program) 的 ConfigureServices Class 中添加 services.AddAutoMapper(typeof(Startup)); // 如果是用 Program 就把 Startup => Program
        3..創建 Profiles 資料夾 -> 創建一個類別項目 -> 引入 Profile
            public class TodoListProfile : Profile // 引入  Profile
            {
                public TodoListProfile()
                {
                    CreateMap<TodoList, TodoListSelectDto>() // AutoMapper 提供的物件 (用來映射兩個物件)
                    // CreateMap<"原物件","被對應物件">()
                }
            }
        4.到 Controller 中注入 DI
            public class TodoController : ControllerBase{
                private readonly IMapper _mapper <= IMapper 是 AutoMapper 給予的物件
                public TodoController(IMapper _mapper){ <= TodoController 是建構函式
                    _mapper = mapper;
                }
            }
        大致寫法
            多筆資料
                [HttpGet("AutoMapper")]
                public IEnumerable<TodoListSelectDto> GetAutoMapper([FromQuery] TodoSelectParameter value)
                {
                    // Include => 將資料表從別的地方撈過來
                    var result = _todoContext.TodoLists
                        .Include(a => a.UpdateEmployee)
                        .Include(a => a.InsertEmployee)
                        // 這裡做轉換有可能會出錯(關鍵字查詢時)
                        .Select(a => a);
                    // 透過函式帶入
                    // .Select(a => ItemToDto(a));
                    if (!string.IsNullOrWhiteSpace(value.name))
                    {
                        // result = result.Where(a => a.Name.Contains(name));
                        result = result.Where(a => a.Name == value.name);
                        result = result.Where(a => a.Name.IndexOf(value.name) > -1);
                    }
                    if (value.enable != null) // 要將上面的 enable 參數設定成 bool? enable 表示不一定會傳進來
                    {
                        result = result.Where(a => a.Enable == value.enable);
                    }
                    if (value.InsertTime != null)
                    {
                        result = result.Where(a => a.InsertTime.Date == value.InsertTime);
                    }
                    if (value.minOrder != null && value.maxOrder != null) // 要將上面的 enable 參數設定成 bool? enable 表示不一定會傳進來
                    {
                        result = result.Where(a => a.Orders >= value.minOrder && a.Orders <= value.maxOrder);
                    }
                    // result (映射) TodoListSelectDto 後存到 map 中
                    var map = _mapper.Map<IEnumerable<TodoListSelectDto>>(result);

                    return map; ;
                }
            單筆資料
                // Profiles 資料夾中的設定檔
                public TodoListProfile()
                {
                    // 將 TodoList 轉換成 TodoListSelecDto
                    // 可以不用 ForMember 
                    CreateMap<TodoList, TodoListSelectDto>()
                        .ForMember(
                            des1 => des1.InsertEmployeeName,
                            opt => opt.MapFrom(src => src.InsertEmployee.Name + "(" + src.InsertEmployee + ")")
                        )
                        .ForMember(
                            des1 => des1.InsertEmployeeName,
                            opt => opt.MapFrom(src => src.UpdateEmployee.Name + "(" + src.UpdateEmployee + ")")
                        );
                }
                // Controller 資料夾中的檔案
                [HttpGet("AutoMapper/{id}")]
                public TodoListSelectDto GetAutoMapper(Guid id)
                {
                    // Include => 將資料表從別的地方撈過來
                    var result = (from a in _todoContext.TodoLists
                                where a.TodoId == id
                                select a).Include(a => a.InsertEmployee)
                        .Include(a => a.UpdateEmployee)
                        .SingleOrDefault();
                    var map = _mapper.Map<TodoListSelectDto>(result);
                    return map; ;
                }
資料庫串接流程(0~1)
    安裝 Microsoft.EntityFrameworkCore.SqlServer、Microsoft.EntityFrameworkCore.Design、Microsoft.EntityFrameworkCore.Tools
    1.創建新資料庫23
    2.創建資料庫的資料表
    3.VStudio 創立一個 Web API 專案 (專案設定)
        1. [使用控制器 (取消核取以使用最小 API)] 核取方塊
        2. [啟用 OpenAPI 支援] 核取方塊
    4.新增 Models 資料夾
    5.新增類別(看有幾筆資料或資料的共通類別)(這裡的檔案相當於一筆資料)
    6.VStudio 用 SQL Server Object Explorer => 加入 SQL Server => 伺服器:SQL 連接的資料庫名稱(從屬性查看)
    7.對資料庫右鍵 => 屬性 => 找到 Connection string => 複製到 appsettings.json中
        "ConnectionStrings": {
            "DefaultConnection": "Data Source=MSI\\SQLEXPRESS;Integrated Security=True;Connect Timeout=30;Encrypt=False;Trust Server Certificate=True;Application Intent=ReadWrite;Multi Subnet Failover=False"
        },
    8.打程式
    9.建立完整的資料庫檔案 Add-Migration InitialCreate
    10.建立資料庫 dotnet run seeddata
資料庫 CRUD
    R (GET)
        [HttpGet("路徑")]
    C (POST)
        [HttpPost]
        ex
            [HttpPost]
            public void Post([FromBody] TodoList value)
            {
                TodoList insert = new TodoList
                {
                    Name = value.Name,
                    Enable = value.Enable,
                    Orders = value.Orders,
                    InsertTime = DateTime.Now,
                    UpdateTime = DateTime.Now,
                    InsertEmployeeId = Guid.Parse("00000000-0000-0000-0000-000000000001"),
                    UpdateEmployeeId = Guid.Parse("00000000-0000-0000-0000-000000000001")
                };

                _NewTodoContext.TodoList.Add(insert);
                _NewTodoContext.SaveChanges();
            }

    U (PUT、PATCH)
        PUT
            [HttpPut("{id}")]
            public string Put(Guid id, [FromBody] TodoList value)
            {
                // 自動匹配
                /_NewTodoContext.TodoList.Update(value);
                _NewTodoContext.TodoList.Entry(value).State = EntityState.Modified;

                // -----------------------------------------------------
                // 特定欄位更新
                var update = _NewTodoContext.TodoList.find(id);
                
                // 系統決定欄位
                update.InsertTime = DateTime.Now;
                update.UpdateTime = DateTime.Now;
                update.InsertEmployeeId = Guid.Parse("00000000-0000-0000-0000-000000000001");
                update.UpdateEmployeeId = Guid.Parse("00000000-0000-0000-0000-000000000001");

                // 使用者可輸入欄位
                update.Name = value.Name;
                update.Orders = value.Orders;
                update.Enable = value.Enable;
            }
        PATCH
            
    D (DELETE)
        當 DELETE 的資料有子資料時，必需說明有哪些子資料，才能將父資料刪除
            (from a in _NewTodoContext.TodoList
                where a.TodoId == id
                select a).Include(c => c.{子資料表}).SingleOrDefault();
        ex
            [HttpDelete("{id}")]
            public string Delete(Guid id)
            {
                var delete = (from a in _NewTodoContext.TodoList
                            where a.TodoId == id
                            select a).SingleOrDefault();
                if(delete != null)
                {
                    _NewTodoContext.TodoList.Remove(delete);
                    _NewTodoContext.SaveChanges();
                }
                return "已完成";
            }
屬性與語法
    屬性
        [AllowAnonymous] 限制已有驗證的使用者才可存取元件
        IWebHostEnvironment 提供兩界面
            1.WebRootPath
                指向 www 文件夾路徑，可以使用這個屬性來獲取或設定包含 Web 服務應用程式文件的目錄的絕對路徑
            2.ContentRootPath
                根文件夾的路徑，可以使用這個屬性來獲取或設定包含所有應用程式文件的目錄的絕對路徑
    語法
        implicit => 不需明確指定轉換類型
        explict => 必須明確轉換類型
    異步
        public async Task<<object> GetExternalDataSets(int dataSourceId)
    型別
        dynamic => 在執行中判斷型別是否有錯
    其他
        FileStream
            使用指定路徑、建立模式和讀取/寫入權限，初始化 FileStream 類別的新執行個體
            寫法
                FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access)
                    1.path 檔案的相對或絕對路徑
                    2.mode 決定如何開啟或建立檔案
                    3.access 決定存取檔案的方式
Error
    無效的物件名稱
        重連 DB 後除其他錯
    
補充
    SQL Server 資料放在 (C:\Program Files\Microsoft SQL Server\{電腦名稱}\MSSQL\DATA)下最好
    one-to-many
        one 設定成 ClassName Class，many 用 ICollection<Class>
        one => 結合其他表格 (ClassName Class)
        many => one 連接到的表格 (ICollection)
    many-to-many
    連接資料庫指令
        appsettings.json
            Server=伺服器名稱;Database=資料庫名稱;User ID=帳號;TrustServerCertificate=true" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Force
            "TodoDatabase": Data Source=MSI\\SQLEXPRESS;AttachDbFilename=C:\\Program Files\\Microsoft SQL Server\\MSSQL15.SQLEXPRESS\\MSSQL\\DATA\\YT_tutorial\\\\Todo.mdf;Integrated Security=True;Connect Timeout=30
        NuGet指令
            Scaffold-DbContext "Server=伺服器名稱;Database=資料庫名稱;User ID=使用者名稱(帳號);TrustServerCertificate=true" Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Force
        透過伺服器總管 -> 連線到資料庫
        透過 SQL Server 物件總管 -> 加入 SQL Server
            伺服器名稱 => MSSQL 伺服器名稱
            資料庫名稱 => MSSQL 伺服器下的資料庫名稱
    資料庫不可變更資料情況下
        工具–>選項–>Designers(設計師)–>資料表和資料庫設計工具–>防止儲存需要資料表重建的變更–>取消勾選 即可
    伺服器
        名稱
            .\SQLEXPRESS <= 本機 "."是正式版可以使用的
    Restful api
        規範
            GET 取得 => api/todo
            GET 取得指定 => api/todo/1
            POST => api/todo
            PUT 更新指定資料 => api/todo/1
            PATCH 更新(指定資料的部分欄位) => api/todo/1
            delete 刪除 => api/todo/1
    LinQ
        只需要理解 LinQ 語法就可以用來查詢各種對象(SQL、Object、XML等)
    Postman
        post => body => raw => JSON => 輸入內容
    DTO (建立資料傳輸物件)
        只要不想把多餘的資料傳輸出去就可以使用，透過 Models 中的資料內容，去除一些不必要內容(增加新內容)，這就是 DTO
        作用
            1.省略不必要屬性
            2.避免過度張貼
        原理
            對原本的資料屬性刪減、新增、更改
        流程
            創建 Dtos 資料夾 -> 新增項目類別 -> 將原本的項目類別的內容貼過來新增的類別 -> 修改(刪減、新增) 
            到控制器中

                var result = _todoContext.TodoLists.Include(a => a.UpdateEmployee).Include(a => a.InsertEmployee)
                    .Select(a => new TodoListSelectDto
                    {
                        Enable = a.Enable,
                        InsertEmployeeName = a.InsertEmployee.Name,
                        InsertTime = a.InsertTime,
                        Name = a.Name,
                        Orders = a.Orders,
                        TodoId = a.TodoId,
                        UpdateEmployeeName = a.UpdateEmployee.Name,
                        UpdateTime = a.UpdateTime,
                    });
                return result;
    回傳狀態碼
        200
            [HttpGet]
            public IActionResult Get(){
                var var result = _todoContext.TodoLists.Include(a => a.UpdateEmployee).Include(a => a.InsertEmployee)
                    .Select(a => new TodoListSelectDto
                    {
                        Enable = a.Enable,
                        InsertEmployeeName = a.InsertEmployee.Name,
                        InsertTime = a.InsertTime,
                        Name = a.Name,
                        Orders = a.Orders,
                        TodoId = a.TodoId,
                        UpdateEmployeeName = a.UpdateEmployee.Name,
                        UpdateTime = a.UpdateTime,
                    });
                return Ok(result); <= Ok() 是 IActionResult function 的方法
            }
        透過狀態碼方法
        [HttpGet]
        public IActionResult Get()
        {
            // DTO
            // Include 將多個相關內容包含至單一查詢
            var result = _todoContext.TodoLists.Include(a => a.UpdateEmployee).Include(a => a.InsertEmployee)
                .Where(a => a.Name == "ae")
                .Select(a => new TodoListSelectDto
                {
                    Enable = a.Enable,
                    InsertEmployeeName = a.InsertEmployee.Name,
                    InsertTime = a.InsertTime,
                    Name = a.Name,
                    Orders = a.Orders,
                    TodoId = a.TodoId,
                    UpdateEmployeeName = a.UpdateEmployee.Name,
                    UpdateTime = a.UpdateTime,
                });
            if(result == null || result.Count() == 0)
            {
                // NotFound 是一個狀態碼的方法
                return NotFound("找不到"); <= NotFound 中也可以放訊息
            }
            return Ok(result);
        }
        直接寫
            [HttpGet]
            public IEnumerable<TodoListSelectDto> Get()
            {
                // DTO
                // Include 將多個相關內容包含至單一查詢
                var result = _todoContext.TodoLists.Include(a => a.UpdateEmployee).Include(a => a.InsertEmployee)
                    .Where(a => a.Name == "ae")
                    .Select(a => new TodoListSelectDto
                    {
                        Enable = a.Enable,
                        InsertEmployeeName = a.InsertEmployee.Name,
                        InsertTime = a.InsertTime,
                        Name = a.Name,
                        Orders = a.Orders,
                        TodoId = a.TodoId,
                        UpdateEmployeeName = a.UpdateEmployee.Name,
                        UpdateTime = a.UpdateTime,
                    });
                if (result == null || result.Count() == 0)
                {
                    Response.StatusCode = 404; // 直接更改代碼
                }
                return result;
            }
    C#構造函式運作方式
        Program.cs and Startup.cs
            Program
                // 表示 Web App
                var builder = WebApplication.CreateBuilder(args);

                // 添加各種 Service 到容器中
                builder.Services.AddControllers();
                builder.Services.AddEndpointsApiExplorer();
                builder.Services.AddSwaggerGen();

                // 實例化，使用 Build 建立
                var app = builder.Build();

                // Configure the HTTP request pipeline.
                if (app.Environment.IsDevelopment())
                {
                    app.UseSwagger();
                    app.UseSwaggerUI();
                }

                // HTTP 自動導向到 HTTPS
                app.UseHttpsRedirection();

                // 啟用權限驗證
                app.UseAuthorization();

                // 映射 Controller
                app.MapControllers();

                app.Run();
            Startup
                常見寫法
                    namespace Todo
                    {
                        public class Startup
                        {
                            public Startup(IConfiguration configuration)
                            {
                                
                                Configuration = configuration;
                            }
                            // IConfiguration 承接 IHostBuilder 的 IConfiguration
                            public IConfiguration Configuration { get; }
                            
                            // 添加服務
                            // (必須是 public，名稱也不能改)
                            public void ConfigureServices(IServiceCollection services)
                            {
                                services.AddControllers();
                            }

                            // 設定 HTTP Request 處理細節的 Configure
                            // (必須是 public，名稱也不能改)
                            public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
                            {
                                if (env.IsDevelopment())
                                {
                                    app.UseDeveloperExceptionPage();
                                }

                                app.UseHttpsRedirection();
                                app.UseRouting();
                                app.UseAuthorization();
                                app.UseEndpoints(endpoints =>
                                {
                                    endpoints.MapControllers();
                                });
                            }
                        }
                    }
    Dto 搭配 FromSqlRaw
        ASP.NET
            [HttpGet("GetSQLDto")]
            public IEnumerable<TodoListSelectDto> GetSQLDto(string name)
            {
                // 這裡會有欄位的差異會出現錯誤
                string sql = "select * from todolist where 1 = 1";
                if (!string.IsNullOrWhiteSpace(name))
                {
                    sql = sql + "and name like N'%" + name + "%'";
                }
                var result = _NewTodoContext.TodoListSelectDto.FromSqlRaw(sql);
                return result;
            }
        MSSQL
            (TodoList 的 code)
            SELECT TOP (1000) [TodoId]
                ,a.[Name] <= 下面的 a
                ,[InsertTime]
                ,[UpdateTime]
                ,[Enable]
                ,[Orders]
                ,b.Name as[InsertEmployeeId] <= 將 InsertEmployee 丟到 b.Name 裡面
                ,c.Name as [UpdateEmployeeId] <= 將 UpdateEmployee 丟到 c.Name 裡面
            FROM [NewTodo].[dbo].[TodoList] a <= 對應到上面的 a.[Name]
            join Employee b on a.InsertEmployeeId = b.EmployeeId <= 將 a.InsertEmployeeId 與 b.EmployeeId 做比較，輸出符合的結果
            join Employee c on a.UpdateEmployeeId = c.EmployeeId <= 將 a.UpdateEmployeeId 與 c.EmployeeId 做比較，輸出符合的結果
    Database First
        將資料庫把資料的結構設計完成後，再到 ASP.NET Core 裡面，對資料庫連線，使用 Enitity Framework 完成 Model 建立

    重點
        1.Models 資料夾中會放入很多獨立的資料表(不算主鍵和外鍵的話)

結構
    .net 5.0
        Program
            程式的進入點，可建立 WebHost 和 WebApplication 的程式碼，也可以設定 Application 服務提供者、配置 Http request 管道
            以及定義應用程式主要邏輯
        Startup
            設定(註冊)應用程式的服務和中間件軟體
    .net 8.0
        Program
            程式進入點，設定(註冊)應用程式的服務和中間件軟體

補充
    服務註冊
        應用程式啟動時，將服務(資料庫連線、身分驗證、日誌紀錄等)添加到服務容器中
            常用法
                public void Configuration(IServiceCollection services) {
                    services.AddDbContext<MyDbContext>() // 註冊服務
                }
    依賴注入(DI)
        將服務注入到應用程式的其他元件中，ex: Controller、MiddleWare、Service 等
            常用法
                public class MyController {
                    private readonly MyDbContext _dbContext // 宣告服務
                    public MyController(MyDbContext dbContext) {
                        _dbContext = dbContext // 注入服務
                    }
                }        

其他 Class
    IApplicationBuilder
        配置應用程序的請求管道
            1.中間件配置
                允許添加、排序、配置中間件 // 中間件 => 處理 Http 請求和響應的軟件組件
            2.請求管道構建
                可以定義請求如何在 application 流動和被處理
            3.服務配置
                某些服務細節可以在這裡設定
            4.路由設置
                配置路由規則
            5.錯誤處理
                設置全局錯誤處理中間件
            6.環境特定配置
                根據不同運行環境配置中間件或行為
        中間件
            UseDeveloperExceptionPage (只可在開發環境使用)
                用於處理開發環境中的錯誤和調試 (https://ithelp.ithome.com.tw/m/articles/10240724)
                    1.詳細錯誤訊息
                        當應用程序拋出未處理的異常時，它會顯示詳細的錯誤頁面，包括堆棧跟蹤、查詢字符串、cookies 等信息
                    2.原代碼顯示
                        錯誤頁面會顯示發生異常的源代碼片段，幫助開發者快速定位問題
                    3.運行時信息
                        提供有關運行時環境的詳細信息，如服務器變量、HTTP 頭等
                    4.僅用於開發
                        這個中間件設計用於開發環境，不應在生產環境中使用，因為它可能暴露敏感信息
                    5.快速診斷
                        有助於開發者快速診斷和修復問題，無需額外的日誌記錄或調試工具
                可傳入 UseDeveloperExceptionOptions 物件
                    DeveloperExceptionPageOptions developerExceptionPageOptions = new DeveloperExceptionPageOptions {
                        SourceCodeLineCount = 4 //顯示的行數為錯誤那行的前後4行
                    }
                    app.UseDeveloperExceptionPage(developerExceptionPageOptions)
            UseExceptionHandler (正式環境的錯誤頁面)
                客製化在正式環境中的錯誤頁面
                    導向
                        app.UseExceptionHandler("/Home/Error"); // 導向 /Home/Error 錯誤頁面
                    設定錯誤訊息
                        app.UseExceptionHandler(errorApp =>
                        {
                            errorApp.Run(async context =>
                            {
                                context.Response.StatusCode = 500;
                                context.Response.ContentType = "application/json";

                                var json = @"{ ""Message"": ""This is Error test."" }";
                                await context.Response.WriteAsync(json);

                            });
                        });
            UseRouting
                在 app 請求處理中添加路由中間件
                    1.啟用路由
                        允許將傳入的 HTTP 請求映射到相應的端點 (ex: controller or Razor page)
                    2.端點選擇
                        負責根據請求的 URL 和其他因素(Http method)選擇適當端點
                    3.中間件管道分割
                        將 Middle ware 分為兩部分
                            1.(身分驗證等)類的中間件在路由前運行
                            2.(授權等)類的中間件在路由後運行
                    4.性能優化
                        提前確定端點，優化後續中間件執行
                    5.與 UseEndpoints 配合
                        常與 UseEndpoints 中間件搭配使用，UseEndpoints 可以定義具體的路由規則
                備註
                    需在(身分驗證、授權等)之前調用
                    UseRouting 只會在中間件管道中調用一次
            UseEndpoints
                定義具體的路由規則
                    1.定義路由規則
                        允許你定義具體的路由規則，將 URL 模式映射到特定的處理程序 (Controller、Rezor page 等)
                    2.端點配置
                        提供一個集中的地方來配置所有的端點
                    3.支持多種端點類型
                        配置不同類型的端點, ex:MVC Controller、 Razor Page、 SignalR 中樞等
                    4.靈活路由模式
                        支持基於屬性的路由和傳統的基於模式的路由
                    5.中間件集成
                        允許在端點級別應用特定的中間件
                    6.性能優化
                        使用端點路由可以提高路由的性能，更有效匹配和生成 URL
                備註
                    通常會在 Configuration 的末尾
            UseHttpsRedirection
                將 Http 的請求轉換成以 Https 請求，確保通信是加密的
            Microsoft.AspNetCore.SpaServices.Extensions
                UseSpaStaticFiles
                    配置應用程式以提供 SPA 應用程式的靜態文件
                    ex:
                        app.UseSpaStaticFiles()
                UseSpa
                    將未匹配到請求路由重新導向到前端程序執行，如不是 API 的請求，都會從這裡轉交給前端程式處理('/home')，這裡通常都會導向 index.html
                    ex:
                        app.UseSpa(spa => {
                            spa.Options.SourcePath = "ClientApp";
                            
                            // 確保開發環境下啟動
                            if (env.IsDevelopment())
                            {
                                // 自動啟動 React 服務器
                                spa.UseReactDevelopmentServer(npmScript: "start");
                            }
                        })
            UseHsts
                告訴 browser 只能與通過 Https 協議的服務器通信，通常會在生產環境中啟用
            
    
    IWebHostEnvironment (Microsoft.AspNetCore.Hosting)
        在 run time 期間判斷目前的執行環境，主要提供目前正在執行的Web hosting Environment資訊
            環境 (專案 -> 屬性 -> 偵錯 -> 開啟debug -> 環境變數 -> ASPNETCORE_ENVIRONMENT 值)
                1.IsDevelopment 開發環境
                2.IsStaging 暫時測試環境
                3.IsProduction 正式環境
                4.IsEnvironment 確認指定值是否為執行環境名
    
    IServiceCollection
        啟動時用於註冊和配置服務
            1.服務註冊
                允許你註冊各種服務，包含內置服務和自定義服務
            2.依賴注入容器配置
                作為配置依賴注入容器的主要方式，定義 application 可用的服務
            3.生命周期管理
                允許你指定服務的生命周期(ex:Transient、Scoped、Singleton)
            4.服務替換和擴展
                提供了替換或擴展現有服務實現的能力
            5.配置選項
                通常用於配置各種框架和 Aplication Service
        搭配方法
            services.AddControllers()
                將服務註冊
            services.AddControllers().AddJsonOptions // 要先註冊服務，再使用轉化為 JSON 的方法
                將資料透過 JSON 序列化轉為 JSON

    IISServerOptions
        提供 IIS 進程內配置
            屬性
                1.AllowSynchronousIO
                    控制是否允許同步 IO 操作
                2.AuthenticationDisplayName
                    設置在登入頁面上顯示的名稱
                3.AutomaticAuthentication
                    為 true，服務器會自動設置 HttpContext.User，否則只在顯示請求時提供身分驗證
                4.MaxRequestBodyBufferSize
                    設置傳入請求的最大位元組上限
                5.MaxRequestBodySize
                    設置請求最大允許大小
    
    IHostedService
        介紹
            Core 內建的背景處理介面，可以簡單透過 BackgroundService 基底類別
        作用
            1.輪詢 DB 以找出變更的背景工作
            2.定期更新某個快取的排定工作
            3.允許在背景執行緒上執行工作的 QueueBackgroundWorkItem 實作
            4.在共用 ILogger 這類通用服務時，於 Web 應用程式背景處理佇列訊息
            5.使用 Task.Run() 啟動背景程式
    
    KestrelServerOptions
        常用於 ASP.Net Core 應用程式的伺服器，但在生產環境中還會搭配反向代理伺服器(ex:IIS、Nginx、Apache)一起使用
    
    NetworkInterface
        介紹
            提供網路介面的組態和統計資訊
        方法
            GetAllNetworkInterfaces()
                傳回物件，其描述本機電腦上的網路介面(包含乙太、區連等資訊)
                內容
                    OperationalStatus => 確認網路介面操作狀態
                        1 Up:開啟
                        2 Down:關閉
                        3 Testing:正在執行測試
                        4 Unknown:狀態未知
                        5 Dormant:正在等待外部事件
                        6 NotPresent:缺少元件而無法傳輸資料封包，缺少的元件通常是硬體元件
                        7 LowerLayerDown:無法傳輸資料封包，因為在一或多個其他介面上執行，而這些「低層」介面中至少有一個已經關閉
                    NetworkInterfaceType => 指定網路類型 (https://learn.microsoft.com/zh-tw/dotnet/api/system.net.networkinformation.networkinterfacetype?view=net-8.0)
                        Ethernet:乙太網路
                方法
                    GetPhysicalAddress()
                        傳回這個介面卡的媒體存取控制 (MAC) 或實體位址
        MAC Address
            媒體存取控制位址(區網位址)，用來確認網路裝置的位址


    CORS
        設定原則名
            const string mainName = '_mainName' // 可隨意取
        加入 CORS 服務
            builder.Services.AddCors(options =>  // 加入 Cors 服務
                {
                    options.AddPolicy(
                        name:mainName,
                        build => {
                            build.AllowAnyOrigin() // 允許任何來源的請求
                               .AllowAnyMethod() // 允許所有的 HTTP Method
                               .AllowAnyHeader() // 允許任何自定義或標準的 HTTP header  （比如認證令牌、用户信息等）
                        }
                    )
                }
            ) 

            app.UseCors(_mainName) // 呼叫 UseCors 方法 (這裡會新增 CORS 的 MiddleWare)，使用原則名稱，這個要放在任何授權之前

